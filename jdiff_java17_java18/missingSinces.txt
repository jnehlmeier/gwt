OK: java.lang.reflect.AnnotatedArrayType Interface
OK: java.lang.reflect.AnnotatedParameterizedType Interface
OK: java.lang.reflect.AnnotatedType Interface
OK: java.lang.reflect.AnnotatedTypeVariable Interface
OK: java.lang.reflect.AnnotatedWildcardType Interface
OK: java.util.Base64 Class
OK: java.util.Base64.Decoder Class
OK: java.util.Base64.Encoder Class
OK: java.util.Calendar.Builder Class
OK: java.util.spi.CalendarDataProvider Class
OK: java.util.spi.CalendarNameProvider Class
OK: java.security.cert.CertPathChecker Interface
OK: java.util.concurrent.CompletableFuture Class
OK: java.util.concurrent.CompletableFuture.AsynchronousCompletionTask Interface
OK: java.util.concurrent.CompletionException Class
OK: java.util.concurrent.CompletionStage Interface
OK: java.util.concurrent.ConcurrentHashMap.KeySetView Class
OK: java.util.concurrent.CountedCompleter Class
OK: java.security.DomainLoadStoreParameter Class
OK: java.util.concurrent.atomic.DoubleAccumulator Class
OK: java.util.concurrent.atomic.DoubleAdder Class
OK: java.util.DoubleSummaryStatistics Class
OK: java.sql.DriverAction Interface
OK: java.security.spec.DSAGenParameterSpec Class
OK: java.lang.reflect.Executable Class
OK: java.lang.FunctionalInterface Class
OK: java.util.IntSummaryStatistics Class
OK: java.sql.JDBCType Class
OK: java.security.KeyStore.Entry.Attribute Interface
MISSING @SINCE TAG: java.lang.invoke.LambdaConversionException Class
MISSING @SINCE TAG: java.lang.invoke.LambdaMetafactory Class
OK: java.util.Locale.FilteringMode Class
OK: java.util.Locale.LanguageRange Class
OK: java.util.concurrent.atomic.LongAccumulator Class
OK: java.util.concurrent.atomic.LongAdder Class
OK: java.util.LongSummaryStatistics Class
OK: java.lang.reflect.MalformedParametersException Class
OK: java.lang.invoke.MethodHandleInfo Interface
OK: java.lang.annotation.Native Class
OK: java.util.Optional Class
OK: java.util.OptionalDouble Class
OK: java.util.OptionalInt Class
OK: java.util.OptionalLong Class
OK: java.lang.reflect.Parameter Class
OK: java.security.PKCS12Attribute Class
OK: java.security.cert.PKIXRevocationChecker Class
MISSING @SINCE TAG: java.security.cert.PKIXRevocationChecker.Option Class
OK: java.util.PrimitiveIterator Interface
OK: java.util.PrimitiveIterator.OfDouble Interface
OK: java.util.PrimitiveIterator.OfInt Interface
OK: java.util.PrimitiveIterator.OfLong Interface
OK: java.lang.annotation.Repeatable Class
OK: java.util.spi.ResourceBundleControlProvider Interface
MISSING @SINCE TAG: java.lang.invoke.SerializedLambda Class
OK: java.util.Spliterator Interface
OK: java.util.Spliterator.OfDouble Interface
OK: java.util.Spliterator.OfInt Interface
OK: java.util.Spliterator.OfLong Interface
OK: java.util.Spliterator.OfPrimitive Interface
OK: java.util.Spliterators Class
OK: java.util.Spliterators.AbstractDoubleSpliterator Class
OK: java.util.Spliterators.AbstractIntSpliterator Class
OK: java.util.Spliterators.AbstractLongSpliterator Class
OK: java.util.Spliterators.AbstractSpliterator Class
OK: java.util.SplittableRandom Class
OK: java.sql.SQLType Interface
OK: java.util.concurrent.locks.StampedLock Class
OK: java.util.StringJoiner Class
OK: java.io.UncheckedIOException Class
OK: java.net.URLPermission Class
OK: java.sql.BatchUpdateException Constructor (java.lang.String, java.lang.String, int, long[], java.lang.Throwable)
MISSING @SINCE TAG: java.lang.reflect.GenericSignatureFormatError Constructor (java.lang.String)
OK: java.lang.InternalError Constructor (java.lang.String, java.lang.Throwable)
OK: java.lang.InternalError Constructor (java.lang.Throwable)
MISSING @SINCE TAG: java.awt.event.InvocationEvent Constructor (java.lang.Object, java.lang.Runnable, java.lang.Runnable, boolean)
OK: java.security.KeyStore.PasswordProtection Constructor (char[], java.lang.String, java.security.spec.AlgorithmParameterSpec)
OK: java.security.KeyStore.PrivateKeyEntry Constructor (java.security.PrivateKey, java.security.cert.Certificate[], java.util.Set<java.security.KeyStore.Entry.Attribute>)
OK: java.security.KeyStore.SecretKeyEntry Constructor (javax.crypto.SecretKey, java.util.Set<java.security.KeyStore.Entry.Attribute>)
OK: java.security.KeyStore.TrustedCertificateEntry Constructor (java.security.cert.Certificate, java.util.Set<java.security.KeyStore.Entry.Attribute>)
OK: java.util.PriorityQueue Constructor (java.util.Comparator<? super E>)
OK: java.lang.VirtualMachineError Constructor (java.lang.String, java.lang.Throwable)
OK: java.lang.VirtualMachineError Constructor (java.lang.Throwable)
OK: java.util.concurrent.atomic.AtomicInteger Method accumulateAndGet(int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerArray Method accumulateAndGet(int, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerFieldUpdater Method accumulateAndGet(T, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.atomic.AtomicLong Method accumulateAndGet(long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.atomic.AtomicLongArray Method accumulateAndGet(int, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.atomic.AtomicLongFieldUpdater Method accumulateAndGet(T, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.atomic.AtomicReference Method accumulateAndGet(V, java.util.function.BinaryOperator<V>)
OK: java.util.concurrent.atomic.AtomicReferenceArray Method accumulateAndGet(int, E, java.util.function.BinaryOperator<E>)
OK: java.util.concurrent.atomic.AtomicReferenceFieldUpdater Method accumulateAndGet(T, V, java.util.function.BinaryOperator<V>)
OK: java.lang.Math Method addExact(int, int)
OK: java.lang.Math Method addExact(long, long)
OK: java.lang.StrictMath Method addExact(int, int)
OK: java.lang.StrictMath Method addExact(long, long)
OK: java.util.regex.Pattern Method asPredicate()
MISSING @SINCE TAG: java.util.concurrent.ForkJoinPool Method awaitQuiescence(long, java.util.concurrent.TimeUnit)
OK: java.math.BigInteger Method byteValueExact()
OK: java.lang.CharSequence Method chars()
NO DOC BLOCK: java.nio.CharBuffer Method chars()
MISSING @SINCE TAG: java.security.cert.PKIXCertPathChecker Method check(java.security.cert.Certificate)
OK: java.util.Collections Method checkedNavigableMap(java.util.NavigableMap<K, V>, java.lang.Class<K>, java.lang.Class<V>)
OK: java.util.Collections Method checkedNavigableSet(java.util.NavigableSet<E>, java.lang.Class<E>)
OK: java.util.Collections Method checkedQueue(java.util.Queue<E>, java.lang.Class<E>)
OK: java.awt.KeyboardFocusManager Method clearFocusOwner()
OK: java.lang.CharSequence Method codePoints()
MISSING @SINCE TAG: java.lang.invoke.MethodHandles Method collectArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle)
OK: java.util.concurrent.ForkJoinPool Method commonPool()
OK: java.util.concurrent.ForkJoinTask Method compareAndSetForkJoinTaskTag(short, short)
OK: java.lang.Integer Method compareUnsigned(int, int)
OK: java.lang.Long Method compareUnsigned(long, long)
OK: java.util.Comparator Method comparing(java.util.function.Function<? super T, ? extends U>)
OK: java.util.Comparator Method comparing(java.util.function.Function<? super T, ? extends U>, java.util.Comparator<? super U>)
OK: java.util.Map.Entry Method comparingByKey()
OK: java.util.Map.Entry Method comparingByKey(java.util.Comparator<? super K>)
OK: java.util.Map.Entry Method comparingByValue()
OK: java.util.Map.Entry Method comparingByValue(java.util.Comparator<? super V>)
OK: java.util.Comparator Method comparingDouble(java.util.function.ToDoubleFunction<? super T>)
OK: java.util.Comparator Method comparingInt(java.util.function.ToIntFunction<? super T>)
OK: java.util.Comparator Method comparingLong(java.util.function.ToLongFunction<? super T>)
OK: java.security.Provider Method compute(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>)
NO DOC BLOCK: java.util.HashMap Method compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.Hashtable Method compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.Map Method compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentMap Method compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentSkipListMap Method compute(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.security.Provider Method computeIfAbsent(java.lang.Object, java.util.function.Function<? super java.lang.Object, ? extends java.lang.Object>)
NO DOC BLOCK: java.util.HashMap Method computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
NO DOC BLOCK: java.util.Hashtable Method computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
OK: java.util.Map Method computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
OK: java.util.concurrent.ConcurrentMap Method computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
OK: java.util.concurrent.ConcurrentSkipListMap Method computeIfAbsent(K, java.util.function.Function<? super K, ? extends V>)
OK: java.security.Provider Method computeIfPresent(java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>)
NO DOC BLOCK: java.util.HashMap Method computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.Hashtable Method computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.Map Method computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentMap Method computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentSkipListMap Method computeIfPresent(K, java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.logging.Logger Method config(java.util.function.Supplier<java.lang.String>)
OK: java.lang.Math Method decrementExact(int)
OK: java.lang.Math Method decrementExact(long)
OK: java.lang.Process Method destroyForcibly()
OK: java.lang.Integer Method divideUnsigned(int, int)
OK: java.lang.Long Method divideUnsigned(long, long)
OK: java.security.AccessController Method doPrivileged(java.security.PrivilegedExceptionAction<T>, java.security.AccessControlContext, java.security.Permission[])
OK: java.security.AccessController Method doPrivileged(java.security.PrivilegedAction<T>, java.security.AccessControlContext, java.security.Permission[])
OK: java.security.AccessController Method doPrivilegedWithCombiner(java.security.PrivilegedExceptionAction<T>, java.security.AccessControlContext, java.security.Permission[])
OK: java.security.AccessController Method doPrivilegedWithCombiner(java.security.PrivilegedAction<T>, java.security.AccessControlContext, java.security.Permission[])
OK: java.util.Random Method doubles()
OK: java.util.Random Method doubles(double, double)
OK: java.util.Random Method doubles(long)
OK: java.util.Random Method doubles(long, double, double)
OK: java.util.concurrent.ThreadLocalRandom Method doubles()
OK: java.util.concurrent.ThreadLocalRandom Method doubles(double, double)
OK: java.util.concurrent.ThreadLocalRandom Method doubles(long)
OK: java.util.concurrent.ThreadLocalRandom Method doubles(long, double, double)
OK: java.util.Collections Method emptyNavigableMap()
OK: java.util.Collections Method emptyNavigableSet()
OK: java.util.Collections Method emptySortedMap()
OK: java.util.Collections Method emptySortedSet()
MISSING @SINCE TAG: java.awt.peer.FramePeer Method emulateActivation(boolean)
OK: java.util.regex.Matcher Method end(java.lang.String)
OK: java.security.cert.CertPathBuilderSpi Method engineGetRevocationChecker()
OK: java.security.cert.CertPathValidatorSpi Method engineGetRevocationChecker()
MISSING @SINCE TAG: java.util.LinkedHashMap Method entrySet()
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method equals(java.lang.Object)
OK: java.sql.Statement Method executeLargeBatch()
OK: java.sql.PreparedStatement Method executeLargeUpdate()
OK: java.sql.Statement Method executeLargeUpdate(java.lang.String)
OK: java.sql.Statement Method executeLargeUpdate(java.lang.String, int)
OK: java.sql.Statement Method executeLargeUpdate(java.lang.String, int[])
OK: java.sql.Statement Method executeLargeUpdate(java.lang.String, java.lang.String[])
OK: java.util.Locale Method filter(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.util.Locale>)
OK: java.util.Locale Method filter(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.util.Locale>, java.util.Locale.FilteringMode)
OK: java.util.Locale Method filterTags(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.lang.String>)
OK: java.util.Locale Method filterTags(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.lang.String>, java.util.Locale.FilteringMode)
OK: java.nio.file.Files Method find(java.nio.file.Path, int, java.util.function.BiPredicate<java.nio.file.Path, java.nio.file.attribute.BasicFileAttributes>, java.nio.file.FileVisitOption[])
OK: java.util.logging.Logger Method fine(java.util.function.Supplier<java.lang.String>)
OK: java.util.logging.Logger Method finer(java.util.function.Supplier<java.lang.String>)
OK: java.util.logging.Logger Method finest(java.util.function.Supplier<java.lang.String>)
OK: java.lang.Math Method floorDiv(int, int)
OK: java.lang.Math Method floorDiv(long, long)
OK: java.lang.StrictMath Method floorDiv(int, int)
OK: java.lang.StrictMath Method floorDiv(long, long)
OK: java.lang.Math Method floorMod(int, int)
OK: java.lang.Math Method floorMod(long, long)
OK: java.lang.StrictMath Method floorMod(int, int)
OK: java.lang.StrictMath Method floorMod(long, long)
OK: java.lang.Iterable Method forEach(java.util.function.Consumer<? super T>)
OK: java.security.Provider Method forEach(java.util.function.BiConsumer<? super java.lang.Object, ? super java.lang.Object>)
NO DOC BLOCK: java.util.ArrayList Method forEach(java.util.function.Consumer<? super E>)
NO DOC BLOCK: java.util.HashMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.Hashtable Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.IdentityHashMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.LinkedHashMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
OK: java.util.Map Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.TreeMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.Vector Method forEach(java.util.function.Consumer<? super E>)
NO DOC BLOCK: java.util.WeakHashMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.concurrent.ConcurrentHashMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
OK: java.util.concurrent.ConcurrentHashMap Method forEach(long, java.util.function.BiConsumer<? super K, ? super V>)
OK: java.util.concurrent.ConcurrentHashMap Method forEach(long, java.util.function.BiFunction<? super K, ? super V, ? extends U>, java.util.function.Consumer<? super U>)
OK: java.util.concurrent.ConcurrentMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.concurrent.ConcurrentSkipListMap Method forEach(java.util.function.BiConsumer<? super K, ? super V>)
NO DOC BLOCK: java.util.concurrent.CopyOnWriteArrayList Method forEach(java.util.function.Consumer<? super E>)
NO DOC BLOCK: java.util.concurrent.CopyOnWriteArraySet Method forEach(java.util.function.Consumer<? super E>)
OK: java.util.concurrent.ConcurrentHashMap Method forEachEntry(long, java.util.function.Consumer<? super java.util.Map.Entry<K, V>>)
OK: java.util.concurrent.ConcurrentHashMap Method forEachEntry(long, java.util.function.Function<java.util.Map.Entry<K, V>, ? extends U>, java.util.function.Consumer<? super U>)
OK: java.util.concurrent.ConcurrentHashMap Method forEachKey(long, java.util.function.Consumer<? super K>)
OK: java.util.concurrent.ConcurrentHashMap Method forEachKey(long, java.util.function.Function<? super K, ? extends U>, java.util.function.Consumer<? super U>)
OK: java.util.Iterator Method forEachRemaining(java.util.function.Consumer<? super E>)
OK: java.util.concurrent.ConcurrentHashMap Method forEachValue(long, java.util.function.Consumer<? super V>)
OK: java.util.concurrent.ConcurrentHashMap Method forEachValue(long, java.util.function.Function<? super V, ? extends U>, java.util.function.Consumer<? super U>)
OK: java.lang.management.LockInfo Method from(javax.management.openmbean.CompositeData)
OK: java.nio.file.attribute.FileTime Method from(java.time.Instant)
OK: java.sql.Timestamp Method from(java.time.Instant)
OK: java.util.Date Method from(java.time.Instant)
OK: java.util.GregorianCalendar Method from(java.time.ZonedDateTime)
OK: java.util.concurrent.atomic.AtomicInteger Method getAndAccumulate(int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerArray Method getAndAccumulate(int, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerFieldUpdater Method getAndAccumulate(T, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.atomic.AtomicLong Method getAndAccumulate(long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.atomic.AtomicLongArray Method getAndAccumulate(int, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.atomic.AtomicLongFieldUpdater Method getAndAccumulate(T, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.atomic.AtomicReference Method getAndAccumulate(V, java.util.function.BinaryOperator<V>)
OK: java.util.concurrent.atomic.AtomicReferenceArray Method getAndAccumulate(int, E, java.util.function.BinaryOperator<E>)
OK: java.util.concurrent.atomic.AtomicReferenceFieldUpdater Method getAndAccumulate(T, V, java.util.function.BinaryOperator<V>)
OK: java.util.concurrent.atomic.AtomicInteger Method getAndUpdate(java.util.function.IntUnaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerArray Method getAndUpdate(int, java.util.function.IntUnaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerFieldUpdater Method getAndUpdate(T, java.util.function.IntUnaryOperator)
OK: java.util.concurrent.atomic.AtomicLong Method getAndUpdate(java.util.function.LongUnaryOperator)
OK: java.util.concurrent.atomic.AtomicLongArray Method getAndUpdate(int, java.util.function.LongUnaryOperator)
OK: java.util.concurrent.atomic.AtomicLongFieldUpdater Method getAndUpdate(T, java.util.function.LongUnaryOperator)
OK: java.util.concurrent.atomic.AtomicReference Method getAndUpdate(java.util.function.UnaryOperator<V>)
OK: java.util.concurrent.atomic.AtomicReferenceArray Method getAndUpdate(int, java.util.function.UnaryOperator<E>)
OK: java.util.concurrent.atomic.AtomicReferenceFieldUpdater Method getAndUpdate(T, java.util.function.UnaryOperator<V>)
OK: java.lang.reflect.TypeVariable Method getAnnotatedBounds()
OK: java.lang.Class Method getAnnotatedInterfaces()
OK: java.lang.reflect.Constructor Method getAnnotatedReceiverType()
OK: java.lang.reflect.Constructor Method getAnnotatedReturnType()
OK: java.lang.reflect.Method Method getAnnotatedReturnType()
OK: java.lang.Class Method getAnnotatedSuperclass()
OK: java.lang.reflect.Field Method getAnnotatedType()
OK: java.lang.Class Method getAnnotationsByType(java.lang.Class<A>)
OK: java.lang.Package Method getAnnotationsByType(java.lang.Class<A>)
OK: java.lang.reflect.AccessibleObject Method getAnnotationsByType(java.lang.Class<T>)
OK: java.lang.reflect.AnnotatedElement Method getAnnotationsByType(java.lang.Class<T>)
OK: java.lang.reflect.Field Method getAnnotationsByType(java.lang.Class<T>)
OK: java.security.KeyStore.Entry Method getAttributes()
OK: java.security.KeyStore.PrivateKeyEntry Method getAttributes()
OK: java.security.KeyStore.SecretKeyEntry Method getAttributes()
OK: java.security.KeyStore.TrustedCertificateEntry Method getAttributes()
OK: java.util.Calendar Method getAvailableCalendarTypes()
OK: java.util.ResourceBundle Method getBaseBundleName()
OK: java.util.Calendar Method getCalendarType()
OK: java.util.GregorianCalendar Method getCalendarType()
OK: java.util.concurrent.ForkJoinPool Method getCommonPoolParallelism()
OK: java.util.zip.ZipEntry Method getCreationTime()
OK: java.lang.Class Method getDeclaredAnnotation(java.lang.Class<A>)
OK: java.lang.Package Method getDeclaredAnnotation(java.lang.Class<A>)
OK: java.lang.reflect.AccessibleObject Method getDeclaredAnnotation(java.lang.Class<T>)
OK: java.lang.reflect.AnnotatedElement Method getDeclaredAnnotation(java.lang.Class<T>)
OK: java.lang.Class Method getDeclaredAnnotationsByType(java.lang.Class<A>)
OK: java.lang.Package Method getDeclaredAnnotationsByType(java.lang.Class<A>)
OK: java.lang.reflect.AccessibleObject Method getDeclaredAnnotationsByType(java.lang.Class<T>)
OK: java.lang.reflect.AnnotatedElement Method getDeclaredAnnotationsByType(java.lang.Class<T>)
OK: java.util.concurrent.ForkJoinTask Method getForkJoinTaskTag()
OK: java.util.spi.TimeZoneNameProvider Method getGenericDisplayName(java.lang.String, int, java.util.Locale)
OK: java.security.SecureRandom Method getInstanceStrong()
OK: java.sql.Statement Method getLargeMaxRows()
OK: java.sql.Statement Method getLargeUpdateCount()
OK: java.sql.BatchUpdateException Method getLargeUpdateCounts()
OK: java.util.zip.ZipEntry Method getLastAccessTime()
OK: java.util.zip.ZipEntry Method getLastModifiedTime()
MISSING @SINCE TAG: java.nio.channels.AsynchronousServerSocketChannel Method getLocalAddress()
MISSING @SINCE TAG: java.nio.channels.AsynchronousSocketChannel Method getLocalAddress()
MISSING @SINCE TAG: java.nio.channels.DatagramChannel Method getLocalAddress()
MISSING @SINCE TAG: java.nio.channels.ServerSocketChannel Method getLocalAddress()
MISSING @SINCE TAG: java.nio.channels.SocketChannel Method getLocalAddress()
OK: java.sql.DatabaseMetaData Method getMaxLogicalLobSize()
OK: java.security.Provider Method getOrDefault(java.lang.Object, java.lang.Object)
NO DOC BLOCK: java.util.HashMap Method getOrDefault(java.lang.Object, V)
NO DOC BLOCK: java.util.Hashtable Method getOrDefault(java.lang.Object, V)
MISSING @SINCE TAG: java.util.LinkedHashMap Method getOrDefault(java.lang.Object, V)
OK: java.util.Map Method getOrDefault(java.lang.Object, V)
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method getOrDefault(java.lang.Object, V)
OK: java.util.concurrent.ConcurrentMap Method getOrDefault(java.lang.Object, V)
OK: java.util.concurrent.ConcurrentSkipListMap Method getOrDefault(java.lang.Object, V)
MISSING @SINCE TAG: java.lang.reflect.Constructor Method getParameterCount()
MISSING @SINCE TAG: java.lang.reflect.Method Method getParameterCount()
OK: java.security.KeyStore.PasswordProtection Method getProtectionAlgorithm()
OK: java.security.KeyStore.PasswordProtection Method getProtectionParameters()
OK: java.security.cert.CertPathBuilder Method getRevocationChecker()
OK: java.security.cert.CertPathValidator Method getRevocationChecker()
OK: java.util.TimeZone Method getTimeZone(java.time.ZoneId)
OK: java.lang.Class Method getTypeName()
OK: java.lang.reflect.Type Method getTypeName()
OK: java.util.Locale Method hasExtensions()
OK: java.lang.Boolean Method hashCode(boolean)
OK: java.lang.Byte Method hashCode(byte)
OK: java.lang.Character Method hashCode(char)
OK: java.lang.Double Method hashCode(double)
OK: java.lang.Float Method hashCode(float)
OK: java.lang.Integer Method hashCode(int)
OK: java.lang.Long Method hashCode(long)
OK: java.lang.Short Method hashCode(short)
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method hashCode()
OK: java.security.Principal Method implies(javax.security.auth.Subject)
OK: java.lang.Math Method incrementExact(int)
OK: java.lang.Math Method incrementExact(long)
OK: java.util.logging.Logger Method info(java.util.function.Supplier<java.lang.String>)
OK: java.util.Random Method ints()
OK: java.util.Random Method ints(int, int)
OK: java.util.Random Method ints(long)
OK: java.util.Random Method ints(long, int, int)
OK: java.util.concurrent.ThreadLocalRandom Method ints()
OK: java.util.concurrent.ThreadLocalRandom Method ints(int, int)
OK: java.util.concurrent.ThreadLocalRandom Method ints(long)
OK: java.util.concurrent.ThreadLocalRandom Method ints(long, int, int)
OK: java.math.BigInteger Method intValueExact()
OK: java.lang.Process Method isAlive()
OK: java.lang.reflect.Method Method isDefault()
OK: java.lang.Double Method isFinite(double)
OK: java.lang.Float Method isFinite(float)
OK: java.util.Objects Method isNull(java.lang.Object)
OK: java.util.spi.LocaleServiceProvider Method isSupportedLocale(java.util.Locale)
OK: java.lang.String Method join(java.lang.CharSequence, java.lang.CharSequence[])
OK: java.lang.String Method join(java.lang.CharSequence, java.lang.Iterable<? extends java.lang.CharSequence>)
MISSING @SINCE TAG: java.util.LinkedHashMap Method keySet()
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method keySet(V)
OK: java.io.BufferedReader Method lines()
OK: java.nio.file.Files Method lines(java.nio.file.Path)
OK: java.nio.file.Files Method lines(java.nio.file.Path, java.nio.charset.Charset)
OK: java.nio.file.Files Method list(java.nio.file.Path)
OK: java.util.logging.Logger Method log(java.util.logging.Level, java.lang.Throwable, java.util.function.Supplier<java.lang.String>)
MISSING @SINCE TAG: java.util.logging.Logger Method log(java.util.logging.Level, java.util.function.Supplier<java.lang.String>)
OK: java.lang.Boolean Method logicalAnd(boolean, boolean)
OK: java.lang.Boolean Method logicalOr(boolean, boolean)
OK: java.lang.Boolean Method logicalXor(boolean, boolean)
OK: java.util.logging.Logger Method logp(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.Throwable, java.util.function.Supplier<java.lang.String>)
OK: java.util.logging.Logger Method logp(java.util.logging.Level, java.lang.String, java.lang.String, java.util.function.Supplier<java.lang.String>)
OK: java.util.logging.Logger Method logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.util.ResourceBundle, java.lang.String, java.lang.Object[])
MISSING @SINCE TAG: java.util.logging.Logger Method logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.Throwable)
OK: java.util.logging.Logger Method logrb(java.util.logging.Level, java.lang.String, java.lang.String, java.util.ResourceBundle, java.lang.String, java.lang.Throwable)
OK: java.util.Random Method longs()
OK: java.util.Random Method longs(long)
OK: java.util.Random Method longs(long, long)
OK: java.util.Random Method longs(long, long, long)
OK: java.util.concurrent.ThreadLocalRandom Method longs()
OK: java.util.concurrent.ThreadLocalRandom Method longs(long)
OK: java.util.concurrent.ThreadLocalRandom Method longs(long, long)
OK: java.util.concurrent.ThreadLocalRandom Method longs(long, long, long)
OK: java.math.BigInteger Method longValueExact()
OK: java.util.Locale Method lookup(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.util.Locale>)
OK: java.util.Locale Method lookupTag(java.util.List<java.util.Locale.LanguageRange>, java.util.Collection<java.lang.String>)
OK: java.util.concurrent.ConcurrentHashMap Method mappingCount()
OK: java.lang.Double Method max(double, double)
OK: java.lang.Float Method max(float, float)
OK: java.lang.Integer Method max(int, int)
OK: java.lang.Long Method max(long, long)
OK: java.security.Provider Method merge(java.lang.Object, java.lang.Object, java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>)
NO DOC BLOCK: java.util.HashMap Method merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
NO DOC BLOCK: java.util.Hashtable Method merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
OK: java.util.Map Method merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentMap Method merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentSkipListMap Method merge(K, V, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
OK: java.lang.Double Method min(double, double)
OK: java.lang.Float Method min(float, float)
OK: java.lang.Integer Method min(int, int)
OK: java.lang.Long Method min(long, long)
OK: java.lang.Math Method multiplyExact(int, int)
OK: java.lang.Math Method multiplyExact(long, long)
OK: java.lang.StrictMath Method multiplyExact(int, int)
OK: java.lang.StrictMath Method multiplyExact(long, long)
OK: java.util.Comparator Method naturalOrder()
OK: java.lang.Math Method negateExact(int)
OK: java.lang.Math Method negateExact(long)
OK: java.nio.file.Files Method newBufferedReader(java.nio.file.Path)
OK: java.nio.file.Files Method newBufferedWriter(java.nio.file.Path, java.nio.file.OpenOption[])
OK: java.util.concurrent.ConcurrentHashMap Method newKeySet()
OK: java.util.concurrent.ConcurrentHashMap Method newKeySet(int)
OK: java.util.concurrent.Executors Method newWorkStealingPool()
OK: java.util.concurrent.Executors Method newWorkStealingPool(int)
MISSING @SINCE TAG: java.util.concurrent.ThreadLocalRandom Method nextDouble()
OK: java.lang.Math Method nextDown(double)
OK: java.lang.Math Method nextDown(float)
OK: java.lang.StrictMath Method nextDown(double)
OK: java.lang.StrictMath Method nextDown(float)
MISSING @SINCE TAG: java.util.concurrent.ThreadLocalRandom Method nextInt()
MISSING @SINCE TAG: java.util.concurrent.ThreadLocalRandom Method nextInt(int)
MISSING @SINCE TAG: java.util.concurrent.ThreadLocalRandom Method nextLong()
OK: java.util.Objects Method nonNull(java.lang.Object)
OK: java.util.Comparator Method nullsFirst(java.util.Comparator<? super T>)
OK: java.util.Comparator Method nullsLast(java.util.Comparator<? super T>)
OK: java.util.Arrays Method parallelPrefix(T[], int, int, java.util.function.BinaryOperator<T>)
OK: java.util.Arrays Method parallelPrefix(T[], java.util.function.BinaryOperator<T>)
OK: java.util.Arrays Method parallelPrefix(double[], int, int, java.util.function.DoubleBinaryOperator)
OK: java.util.Arrays Method parallelPrefix(double[], java.util.function.DoubleBinaryOperator)
OK: java.util.Arrays Method parallelPrefix(int[], int, int, java.util.function.IntBinaryOperator)
OK: java.util.Arrays Method parallelPrefix(int[], java.util.function.IntBinaryOperator)
OK: java.util.Arrays Method parallelPrefix(long[], int, int, java.util.function.LongBinaryOperator)
OK: java.util.Arrays Method parallelPrefix(long[], java.util.function.LongBinaryOperator)
OK: java.util.Arrays Method parallelSetAll(T[], java.util.function.IntFunction<? extends T>)
OK: java.util.Arrays Method parallelSetAll(double[], java.util.function.IntToDoubleFunction)
OK: java.util.Arrays Method parallelSetAll(int[], java.util.function.IntUnaryOperator)
OK: java.util.Arrays Method parallelSetAll(long[], java.util.function.IntToLongFunction)
OK: java.util.Arrays Method parallelSort(T[])
OK: java.util.Arrays Method parallelSort(T[], int, int)
OK: java.util.Arrays Method parallelSort(T[], int, int, java.util.Comparator<? super T>)
OK: java.util.Arrays Method parallelSort(T[], java.util.Comparator<? super T>)
OK: java.util.Arrays Method parallelSort(byte[])
OK: java.util.Arrays Method parallelSort(byte[], int, int)
OK: java.util.Arrays Method parallelSort(char[])
OK: java.util.Arrays Method parallelSort(char[], int, int)
OK: java.util.Arrays Method parallelSort(double[])
OK: java.util.Arrays Method parallelSort(double[], int, int)
OK: java.util.Arrays Method parallelSort(float[])
OK: java.util.Arrays Method parallelSort(float[], int, int)
OK: java.util.Arrays Method parallelSort(int[])
OK: java.util.Arrays Method parallelSort(int[], int, int)
OK: java.util.Arrays Method parallelSort(long[])
OK: java.util.Arrays Method parallelSort(long[], int, int)
OK: java.util.Arrays Method parallelSort(short[])
OK: java.util.Arrays Method parallelSort(short[], int, int)
OK: java.util.Collection Method parallelStream()
OK: java.lang.reflect.Modifier Method parameterModifiers()
OK: java.lang.Integer Method parseUnsignedInt(java.lang.String)
OK: java.lang.Integer Method parseUnsignedInt(java.lang.String, int)
OK: java.lang.Long Method parseUnsignedLong(java.lang.String)
OK: java.lang.Long Method parseUnsignedLong(java.lang.String, int)
OK: java.security.Provider Method putIfAbsent(java.lang.Object, java.lang.Object)
NO DOC BLOCK: java.util.HashMap Method putIfAbsent(K, V)
NO DOC BLOCK: java.util.Hashtable Method putIfAbsent(K, V)
OK: java.util.Map Method putIfAbsent(K, V)
OK: java.util.concurrent.ForkJoinTask Method quietlyComplete()
OK: java.nio.file.Files Method readAllLines(java.nio.file.Path)
OK: java.sql.SQLInput Method readObject(java.lang.Class<T>)
OK: java.util.concurrent.ConcurrentHashMap Method reduce(long, java.util.function.BiFunction<? super K, ? super V, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceEntries(long, java.util.function.Function<java.util.Map.Entry<K, V>, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceEntries(long, java.util.function.BiFunction<java.util.Map.Entry<K, V>, java.util.Map.Entry<K, V>, ? extends java.util.Map.Entry<K, V>>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceEntriesToDouble(long, java.util.function.ToDoubleFunction<java.util.Map.Entry<K, V>>, double, java.util.function.DoubleBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceEntriesToInt(long, java.util.function.ToIntFunction<java.util.Map.Entry<K, V>>, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceEntriesToLong(long, java.util.function.ToLongFunction<java.util.Map.Entry<K, V>>, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceKeys(long, java.util.function.BiFunction<? super K, ? super K, ? extends K>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceKeys(long, java.util.function.Function<? super K, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceKeysToDouble(long, java.util.function.ToDoubleFunction<? super K>, double, java.util.function.DoubleBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceKeysToInt(long, java.util.function.ToIntFunction<? super K>, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceKeysToLong(long, java.util.function.ToLongFunction<? super K>, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceToDouble(long, java.util.function.ToDoubleBiFunction<? super K, ? super V>, double, java.util.function.DoubleBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceToInt(long, java.util.function.ToIntBiFunction<? super K, ? super V>, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceToLong(long, java.util.function.ToLongBiFunction<? super K, ? super V>, long, java.util.function.LongBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceValues(long, java.util.function.Function<? super V, ? extends U>, java.util.function.BiFunction<? super U, ? super U, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceValues(long, java.util.function.BiFunction<? super V, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentHashMap Method reduceValuesToDouble(long, java.util.function.ToDoubleFunction<? super V>, double, java.util.function.DoubleBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceValuesToInt(long, java.util.function.ToIntFunction<? super V>, int, java.util.function.IntBinaryOperator)
OK: java.util.concurrent.ConcurrentHashMap Method reduceValuesToLong(long, java.util.function.ToLongFunction<? super V>, long, java.util.function.LongBinaryOperator)
OK: java.lang.invoke.MethodHandles Method reflectAs(java.lang.Class<T>, java.lang.invoke.MethodHandle)
OK: java.sql.DriverManager Method registerDriver(java.sql.Driver, java.sql.DriverAction)
OK: java.sql.CallableStatement Method registerOutParameter(int, java.sql.SQLType)
OK: java.sql.CallableStatement Method registerOutParameter(int, java.sql.SQLType, int)
OK: java.sql.CallableStatement Method registerOutParameter(int, java.sql.SQLType, java.lang.String)
OK: java.sql.CallableStatement Method registerOutParameter(java.lang.String, java.sql.SQLType)
OK: java.sql.CallableStatement Method registerOutParameter(java.lang.String, java.sql.SQLType, int)
OK: java.sql.CallableStatement Method registerOutParameter(java.lang.String, java.sql.SQLType, java.lang.String)
OK: java.lang.Integer Method remainderUnsigned(int, int)
OK: java.lang.Long Method remainderUnsigned(long, long)
OK: java.security.Provider Method remove(java.lang.Object, java.lang.Object)
NO DOC BLOCK: java.util.HashMap Method remove(java.lang.Object, java.lang.Object)
NO DOC BLOCK: java.util.Hashtable Method remove(java.lang.Object, java.lang.Object)
OK: java.util.Map Method remove(java.lang.Object, java.lang.Object)
NO DOC BLOCK: java.util.ArrayList Method removeIf(java.util.function.Predicate<? super E>)
OK: java.util.Collection Method removeIf(java.util.function.Predicate<? super E>)
NO DOC BLOCK: java.util.Vector Method removeIf(java.util.function.Predicate<? super E>)
NO DOC BLOCK: java.util.concurrent.CopyOnWriteArrayList Method removeIf(java.util.function.Predicate<? super E>)
NO DOC BLOCK: java.util.concurrent.CopyOnWriteArraySet Method removeIf(java.util.function.Predicate<? super E>)
OK: java.security.Provider Method replace(java.lang.Object, java.lang.Object, java.lang.Object)
OK: java.security.Provider Method replace(java.lang.Object, java.lang.Object)
NO DOC BLOCK: java.util.HashMap Method replace(K, V)
NO DOC BLOCK: java.util.HashMap Method replace(K, V, V)
NO DOC BLOCK: java.util.Hashtable Method replace(K, V)
NO DOC BLOCK: java.util.Hashtable Method replace(K, V, V)
OK: java.util.Map Method replace(K, V)
OK: java.util.Map Method replace(K, V, V)
NO DOC BLOCK: java.util.TreeMap Method replace(K, V)
NO DOC BLOCK: java.util.TreeMap Method replace(K, V, V)
OK: java.security.Provider Method replaceAll(java.util.function.BiFunction<? super java.lang.Object, ? super java.lang.Object, ? extends java.lang.Object>)
NO DOC BLOCK: java.util.ArrayList Method replaceAll(java.util.function.UnaryOperator<E>)
NO DOC BLOCK: java.util.HashMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.Hashtable Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.IdentityHashMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.LinkedHashMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.List Method replaceAll(java.util.function.UnaryOperator<E>)
OK: java.util.Map Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.TreeMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.Vector Method replaceAll(java.util.function.UnaryOperator<E>)
NO DOC BLOCK: java.util.WeakHashMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.concurrent.ConcurrentHashMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
OK: java.util.concurrent.ConcurrentMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.concurrent.ConcurrentSkipListMap Method replaceAll(java.util.function.BiFunction<? super K, ? super V, ? extends V>)
NO DOC BLOCK: java.util.concurrent.CopyOnWriteArrayList Method replaceAll(java.util.function.UnaryOperator<E>)
OK: java.util.Objects Method requireNonNull(T, java.util.function.Supplier<java.lang.String>)
OK: java.lang.invoke.MethodHandles.Lookup Method revealDirect(java.lang.invoke.MethodHandle)
OK: java.util.Comparator Method reversed()
OK: java.util.Comparator Method reverseOrder()
OK: java.util.concurrent.ConcurrentHashMap Method search(long, java.util.function.BiFunction<? super K, ? super V, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method searchEntries(long, java.util.function.Function<java.util.Map.Entry<K, V>, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method searchKeys(long, java.util.function.Function<? super K, ? extends U>)
OK: java.util.concurrent.ConcurrentHashMap Method searchValues(long, java.util.function.Function<? super V, ? extends U>)
OK: java.util.Arrays Method setAll(T[], java.util.function.IntFunction<? extends T>)
OK: java.util.Arrays Method setAll(double[], java.util.function.IntToDoubleFunction)
OK: java.util.Arrays Method setAll(int[], java.util.function.IntUnaryOperator)
OK: java.util.Arrays Method setAll(long[], java.util.function.IntToLongFunction)
OK: java.util.zip.ZipEntry Method setCreationTime(java.nio.file.attribute.FileTime)
OK: java.util.concurrent.ForkJoinTask Method setForkJoinTaskTag(short)
OK: java.sql.Statement Method setLargeMaxRows(long)
OK: java.util.zip.ZipEntry Method setLastAccessTime(java.nio.file.attribute.FileTime)
OK: java.util.zip.ZipEntry Method setLastModifiedTime(java.nio.file.attribute.FileTime)
OK: java.sql.CallableStatement Method setObject(java.lang.String, java.lang.Object, java.sql.SQLType)
OK: java.sql.CallableStatement Method setObject(java.lang.String, java.lang.Object, java.sql.SQLType, int)
OK: java.sql.PreparedStatement Method setObject(int, java.lang.Object, java.sql.SQLType)
OK: java.sql.PreparedStatement Method setObject(int, java.lang.Object, java.sql.SQLType, int)
OK: java.util.logging.Logger Method setResourceBundle(java.util.ResourceBundle)
OK: java.util.logging.Logger Method severe(java.util.function.Supplier<java.lang.String>)
OK: java.math.BigInteger Method shortValueExact()
NO DOC BLOCK: java.util.ArrayList Method sort(java.util.Comparator<? super E>)
OK: java.util.List Method sort(java.util.Comparator<? super E>)
NO DOC BLOCK: java.util.Vector Method sort(java.util.Comparator<? super E>)
NO DOC BLOCK: java.util.concurrent.CopyOnWriteArrayList Method sort(java.util.Comparator<? super E>)
OK: java.util.regex.Pattern Method splitAsStream(java.lang.CharSequence)
OK: java.lang.Iterable Method spliterator()
OK: java.util.ArrayDeque Method spliterator()
OK: java.util.ArrayList Method spliterator()
OK: java.util.Arrays Method spliterator(double[])
OK: java.util.Arrays Method spliterator(double[], int, int)
OK: java.util.Arrays Method spliterator(int[])
OK: java.util.Arrays Method spliterator(int[], int, int)
OK: java.util.Arrays Method spliterator(long[])
OK: java.util.Arrays Method spliterator(long[], int, int)
OK: java.util.Arrays Method spliterator(T[])
OK: java.util.Arrays Method spliterator(T[], int, int)
OK: java.util.Collection Method spliterator()
OK: java.util.HashSet Method spliterator()
OK: java.util.LinkedHashSet Method spliterator()
OK: java.util.LinkedList Method spliterator()
OK: java.util.List Method spliterator()
OK: java.util.PriorityQueue Method spliterator()
OK: java.util.Set Method spliterator()
OK: java.util.SortedSet Method spliterator()
OK: java.util.TreeSet Method spliterator()
OK: java.util.Vector Method spliterator()
OK: java.util.concurrent.ArrayBlockingQueue Method spliterator()
OK: java.util.concurrent.ConcurrentLinkedDeque Method spliterator()
OK: java.util.concurrent.ConcurrentLinkedQueue Method spliterator()
OK: java.util.concurrent.ConcurrentSkipListSet Method spliterator()
OK: java.util.concurrent.CopyOnWriteArrayList Method spliterator()
OK: java.util.concurrent.CopyOnWriteArraySet Method spliterator()
OK: java.util.concurrent.LinkedBlockingDeque Method spliterator()
OK: java.util.concurrent.LinkedBlockingQueue Method spliterator()
OK: java.util.concurrent.LinkedTransferQueue Method spliterator()
OK: java.util.concurrent.PriorityBlockingQueue Method spliterator()
OK: java.util.concurrent.SynchronousQueue Method spliterator()
OK: java.util.regex.Matcher Method start(java.lang.String)
OK: java.util.Arrays Method stream(double[])
OK: java.util.Arrays Method stream(double[], int, int)
OK: java.util.Arrays Method stream(int[])
OK: java.util.Arrays Method stream(int[], int, int)
OK: java.util.Arrays Method stream(long[])
OK: java.util.Arrays Method stream(long[], int, int)
OK: java.util.Arrays Method stream(T[])
OK: java.util.Arrays Method stream(T[], int, int)
OK: java.util.BitSet Method stream()
OK: java.util.Collection Method stream()
NO DOC BLOCK: java.util.jar.JarFile Method stream()
OK: java.util.zip.ZipFile Method stream()
OK: java.util.Locale Method stripExtensions()
OK: java.lang.Math Method subtractExact(int, int)
OK: java.lang.Math Method subtractExact(long, long)
OK: java.lang.StrictMath Method subtractExact(int, int)
OK: java.lang.StrictMath Method subtractExact(long, long)
OK: java.lang.Double Method sum(double, double)
OK: java.lang.Float Method sum(float, float)
OK: java.lang.Integer Method sum(int, int)
OK: java.lang.Long Method sum(long, long)
OK: java.sql.DatabaseMetaData Method supportsRefCursors()
OK: java.util.Collections Method synchronizedNavigableMap(java.util.NavigableMap<K, V>)
OK: java.util.Collections Method synchronizedNavigableSet(java.util.NavigableSet<T>)
OK: java.util.Comparator Method thenComparing(java.util.Comparator<? super T>)
OK: java.util.Comparator Method thenComparing(java.util.function.Function<? super T, ? extends U>)
OK: java.util.Comparator Method thenComparing(java.util.function.Function<? super T, ? extends U>, java.util.Comparator<? super U>)
OK: java.util.Comparator Method thenComparingDouble(java.util.function.ToDoubleFunction<? super T>)
OK: java.util.Comparator Method thenComparingInt(java.util.function.ToIntFunction<? super T>)
OK: java.util.Comparator Method thenComparingLong(java.util.function.ToLongFunction<? super T>)
OK: java.lang.Class Method toGenericString()
OK: java.nio.file.attribute.FileTime Method toInstant()
MISSING @SINCE TAG: java.sql.Date Method toInstant()
MISSING @SINCE TAG: java.sql.Time Method toInstant()
OK: java.sql.Timestamp Method toInstant()
OK: java.util.Calendar Method toInstant()
OK: java.util.Date Method toInstant()
OK: java.lang.Math Method toIntExact(long)
OK: java.lang.StrictMath Method toIntExact(long)
OK: java.sql.Date Method toLocalDate()
OK: java.sql.Timestamp Method toLocalDateTime()
OK: java.sql.Time Method toLocalTime()
MISSING @SINCE TAG: java.util.concurrent.ConcurrentHashMap Method toString()
OK: java.lang.Byte Method toUnsignedInt(byte)
OK: java.lang.Short Method toUnsignedInt(short)
OK: java.lang.Byte Method toUnsignedLong(byte)
OK: java.lang.Integer Method toUnsignedLong(int)
OK: java.lang.Short Method toUnsignedLong(short)
OK: java.lang.Integer Method toUnsignedString(int)
OK: java.lang.Integer Method toUnsignedString(int, int)
OK: java.lang.Long Method toUnsignedString(long)
OK: java.lang.Long Method toUnsignedString(long, int)
OK: java.util.GregorianCalendar Method toZonedDateTime()
OK: java.util.TimeZone Method toZoneId()
OK: java.util.Collections Method unmodifiableNavigableMap(java.util.NavigableMap<K, ? extends V>)
OK: java.util.Collections Method unmodifiableNavigableSet(java.util.NavigableSet<T>)
OK: java.util.zip.Adler32 Method update(java.nio.ByteBuffer)
OK: java.util.zip.CRC32 Method update(java.nio.ByteBuffer)
OK: java.util.concurrent.atomic.AtomicInteger Method updateAndGet(java.util.function.IntUnaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerArray Method updateAndGet(int, java.util.function.IntUnaryOperator)
OK: java.util.concurrent.atomic.AtomicIntegerFieldUpdater Method updateAndGet(T, java.util.function.IntUnaryOperator)
OK: java.util.concurrent.atomic.AtomicLong Method updateAndGet(java.util.function.LongUnaryOperator)
OK: java.util.concurrent.atomic.AtomicLongArray Method updateAndGet(int, java.util.function.LongUnaryOperator)
OK: java.util.concurrent.atomic.AtomicLongFieldUpdater Method updateAndGet(T, java.util.function.LongUnaryOperator)
OK: java.util.concurrent.atomic.AtomicReference Method updateAndGet(java.util.function.UnaryOperator<V>)
OK: java.util.concurrent.atomic.AtomicReferenceArray Method updateAndGet(int, java.util.function.UnaryOperator<E>)
OK: java.util.concurrent.atomic.AtomicReferenceFieldUpdater Method updateAndGet(T, java.util.function.UnaryOperator<V>)
OK: java.sql.ResultSet Method updateObject(int, java.lang.Object, java.sql.SQLType)
OK: java.sql.ResultSet Method updateObject(int, java.lang.Object, java.sql.SQLType, int)
OK: java.sql.ResultSet Method updateObject(java.lang.String, java.lang.Object, java.sql.SQLType)
OK: java.sql.ResultSet Method updateObject(java.lang.String, java.lang.Object, java.sql.SQLType, int)
OK: java.sql.Date Method valueOf(java.time.LocalDate)
OK: java.sql.Time Method valueOf(java.time.LocalTime)
OK: java.sql.Timestamp Method valueOf(java.time.LocalDateTime)
MISSING @SINCE TAG: java.util.LinkedHashMap Method values()
OK: java.security.cert.Certificate Method verify(java.security.PublicKey, java.security.Provider)
OK: java.security.cert.X509CRL Method verify(java.security.PublicKey, java.security.Provider)
OK: java.security.cert.X509Certificate Method verify(java.security.PublicKey, java.security.Provider)
OK: java.lang.Process Method waitFor(long, java.util.concurrent.TimeUnit)
OK: java.nio.file.Files Method walk(java.nio.file.Path, int, java.nio.file.FileVisitOption[])
OK: java.nio.file.Files Method walk(java.nio.file.Path, java.nio.file.FileVisitOption[])
OK: java.util.logging.Logger Method warning(java.util.function.Supplier<java.lang.String>)
OK: java.lang.ThreadLocal Method withInitial(java.util.function.Supplier<? extends S>)
OK: java.nio.file.Files Method write(java.nio.file.Path, java.lang.Iterable<? extends java.lang.CharSequence>, java.nio.file.OpenOption[])
OK: java.sql.SQLOutput Method writeObject(java.lang.Object, java.sql.SQLType)
MISSING @SINCE TAG: java.awt.Component Field accessibleContext
MISSING @SINCE TAG: java.awt.datatransfer.DataFlavor Field allHtmlFlavor
OK: java.lang.Character.UnicodeBlock Field ARABIC_EXTENDED_A
OK: java.lang.Character.UnicodeBlock Field ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS
OK: java.lang.Byte Field BYTES
OK: java.lang.Character Field BYTES
OK: java.lang.Double Field BYTES
OK: java.lang.Float Field BYTES
OK: java.lang.Integer Field BYTES
OK: java.lang.Long Field BYTES
OK: java.lang.Short Field BYTES
OK: java.lang.Character.UnicodeBlock Field CHAKMA
MISSING @SINCE TAG: java.awt.datatransfer.DataFlavor Field fragmentHtmlFlavor
OK: java.util.Calendar Field LONG_FORMAT
OK: java.util.Calendar Field LONG_STANDALONE
OK: java.lang.Character.UnicodeBlock Field MEETEI_MAYEK_EXTENSIONS
OK: java.lang.Character.UnicodeBlock Field MEROITIC_CURSIVE
OK: java.lang.Character.UnicodeBlock Field MEROITIC_HIEROGLYPHS
OK: java.lang.Character.UnicodeBlock Field MIAO
OK: java.util.Calendar Field NARROW_FORMAT
OK: java.util.Calendar Field NARROW_STANDALONE
OK: java.sql.Types Field REF_CURSOR
MISSING @SINCE TAG: java.awt.datatransfer.DataFlavor Field selectionHtmlFlavor
MISSING @SINCE TAG: java.security.spec.MGF1ParameterSpec Field SHA224
OK: java.lang.Character.UnicodeBlock Field SHARADA
OK: java.util.Calendar Field SHORT_FORMAT
OK: java.util.Calendar Field SHORT_STANDALONE
OK: java.lang.Character.UnicodeBlock Field SORA_SOMPENG
OK: java.lang.Character.UnicodeBlock Field SUNDANESE_SUPPLEMENT
OK: java.lang.Character.UnicodeBlock Field TAKRI
OK: java.sql.Types Field TIME_WITH_TIMEZONE
OK: java.sql.Types Field TIMESTAMP_WITH_TIMEZONE
